const Chip8 = require('./chip8');

const vm = new Chip8();

const DISPLAY_WIDTH = 64;
const DISPLAY_HEIGHT = 32;
const PIXEL_SIZE = 10;
const DISPLAY_COLOR_BG = "#c2c2c2";
const DISPLAY_COLOR_FG = "#000000";

const myCanvas = document.getElementById("chip8-canvas").getContext("2d");
myCanvas.fillStyle = DISPLAY_COLOR_BG;
myCanvas.fillRect(0, 0, DISPLAY_WIDTH * PIXEL_SIZE, DISPLAY_HEIGHT * PIXEL_SIZE);
myCanvas.fillStyle = DISPLAY_COLOR_FG;
myCanvas.font = "bold 36px Arial";
myCanvas.fillText("CHIP-8", 250, 160);

const gameTetris = [
    0xa2, 0xb4, 0x23, 0xe6, 0x22, 0xb6, 0x70, 0x01, 0xd0, 0x11, 0x30, 0x25,
    0x12, 0x06, 0x71, 0xff, 0xd0, 0x11, 0x60, 0x1a, 0xd0, 0x11, 0x60, 0x25,
    0x31, 0x00, 0x12, 0x0e, 0xc4, 0x70, 0x44, 0x70, 0x12, 0x1c, 0xc3, 0x03,
    0x60, 0x1e, 0x61, 0x03, 0x22, 0x5c, 0xf5, 0x15, 0xd0, 0x14, 0x3f, 0x01,
    0x12, 0x3c, 0xd0, 0x14, 0x71, 0xff, 0xd0, 0x14, 0x23, 0x40, 0x12, 0x1c,
    0xe7, 0xa1, 0x22, 0x72, 0xe8, 0xa1, 0x22, 0x84, 0xe9, 0xa1, 0x22, 0x96,
    0xe2, 0x9e, 0x12, 0x50, 0x66, 0x00, 0xf6, 0x15, 0xf6, 0x07, 0x36, 0x00,
    0x12, 0x3c, 0xd0, 0x14, 0x71, 0x01, 0x12, 0x2a, 0xa2, 0xc4, 0xf4, 0x1e,
    0x66, 0x00, 0x43, 0x01, 0x66, 0x04, 0x43, 0x02, 0x66, 0x08, 0x43, 0x03,
    0x66, 0x0c, 0xf6, 0x1e, 0x00, 0xee, 0xd0, 0x14, 0x70, 0xff, 0x23, 0x34,
    0x3f, 0x01, 0x00, 0xee, 0xd0, 0x14, 0x70, 0x01, 0x23, 0x34, 0x00, 0xee,
    0xd0, 0x14, 0x70, 0x01, 0x23, 0x34, 0x3f, 0x01, 0x00, 0xee, 0xd0, 0x14,
    0x70, 0xff, 0x23, 0x34, 0x00, 0xee, 0xd0, 0x14, 0x73, 0x01, 0x43, 0x04,
    0x63, 0x00, 0x22, 0x5c, 0x23, 0x34, 0x3f, 0x01, 0x00, 0xee, 0xd0, 0x14,
    0x73, 0xff, 0x43, 0xff, 0x63, 0x03, 0x22, 0x5c, 0x23, 0x34, 0x00, 0xee,
    0x80, 0x00, 0x67, 0x05, 0x68, 0x06, 0x69, 0x04, 0x61, 0x1f, 0x65, 0x10,
    0x62, 0x07, 0x00, 0xee, 0x40, 0xe0, 0x00, 0x00, 0x40, 0xc0, 0x40, 0x00,
    0x00, 0xe0, 0x40, 0x00, 0x40, 0x60, 0x40, 0x00, 0x40, 0x40, 0x60, 0x00,
    0x20, 0xe0, 0x00, 0x00, 0xc0, 0x40, 0x40, 0x00, 0x00, 0xe0, 0x80, 0x00,
    0x40, 0x40, 0xc0, 0x00, 0x00, 0xe0, 0x20, 0x00, 0x60, 0x40, 0x40, 0x00,
    0x80, 0xe0, 0x00, 0x00, 0x40, 0xc0, 0x80, 0x00, 0xc0, 0x60, 0x00, 0x00,
    0x40, 0xc0, 0x80, 0x00, 0xc0, 0x60, 0x00, 0x00, 0x80, 0xc0, 0x40, 0x00,
    0x00, 0x60, 0xc0, 0x00, 0x80, 0xc0, 0x40, 0x00, 0x00, 0x60, 0xc0, 0x00,
    0xc0, 0xc0, 0x00, 0x00, 0xc0, 0xc0, 0x00, 0x00, 0xc0, 0xc0, 0x00, 0x00,
    0xc0, 0xc0, 0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x00, 0xf0, 0x00, 0x00,
    0x40, 0x40, 0x40, 0x40, 0x00, 0xf0, 0x00, 0x00, 0xd0, 0x14, 0x66, 0x35,
    0x76, 0xff, 0x36, 0x00, 0x13, 0x38, 0x00, 0xee, 0xa2, 0xb4, 0x8c, 0x10,
    0x3c, 0x1e, 0x7c, 0x01, 0x3c, 0x1e, 0x7c, 0x01, 0x3c, 0x1e, 0x7c, 0x01,
    0x23, 0x5e, 0x4b, 0x0a, 0x23, 0x72, 0x91, 0xc0, 0x00, 0xee, 0x71, 0x01,
    0x13, 0x50, 0x60, 0x1b, 0x6b, 0x00, 0xd0, 0x11, 0x3f, 0x00, 0x7b, 0x01,
    0xd0, 0x11, 0x70, 0x01, 0x30, 0x25, 0x13, 0x62, 0x00, 0xee, 0x60, 0x1b,
    0xd0, 0x11, 0x70, 0x01, 0x30, 0x25, 0x13, 0x74, 0x8e, 0x10, 0x8d, 0xe0,
    0x7e, 0xff, 0x60, 0x1b, 0x6b, 0x00, 0xd0, 0xe1, 0x3f, 0x00, 0x13, 0x90,
    0xd0, 0xe1, 0x13, 0x94, 0xd0, 0xd1, 0x7b, 0x01, 0x70, 0x01, 0x30, 0x25,
    0x13, 0x86, 0x4b, 0x00, 0x13, 0xa6, 0x7d, 0xff, 0x7e, 0xff, 0x3d, 0x01,
    0x13, 0x82, 0x23, 0xc0, 0x3f, 0x01, 0x23, 0xc0, 0x7a, 0x01, 0x23, 0xc0,
    0x80, 0xa0, 0x6d, 0x07, 0x80, 0xd2, 0x40, 0x04, 0x75, 0xfe, 0x45, 0x02,
    0x65, 0x04, 0x00, 0xee, 0xa7, 0x00, 0xf2, 0x55, 0xa8, 0x04, 0xfa, 0x33,
    0xf2, 0x65, 0xf0, 0x29, 0x6d, 0x32, 0x6e, 0x00, 0xdd, 0xe5, 0x7d, 0x05,
    0xf1, 0x29, 0xdd, 0xe5, 0x7d, 0x05, 0xf2, 0x29, 0xdd, 0xe5, 0xa7, 0x00,
    0xf2, 0x65, 0xa2, 0xb4, 0x00, 0xee, 0x6a, 0x00, 0x60, 0x19, 0x00, 0xee,
    0x37, 0x23
];

const gameWipeoff = [
    0xa2, 0xcc, 0x6a, 0x07, 0x61, 0x00, 0x6b, 0x08, 0x60, 0x00, 0xd0, 0x11,
    0x70, 0x08, 0x7b, 0xff, 0x3b, 0x00, 0x12, 0x0a, 0x71, 0x04, 0x7a, 0xff,
    0x3a, 0x00, 0x12, 0x06, 0x66, 0x00, 0x67, 0x10, 0xa2, 0xcd, 0x60, 0x20,
    0x61, 0x1e, 0xd0, 0x11, 0x63, 0x1d, 0x62, 0x3f, 0x82, 0x02, 0x77, 0xff,
    0x47, 0x00, 0x12, 0xaa, 0xff, 0x0a, 0xa2, 0xcb, 0xd2, 0x31, 0x65, 0xff,
    0xc4, 0x01, 0x34, 0x01, 0x64, 0xff, 0xa2, 0xcd, 0x6c, 0x00, 0x6e, 0x04,
    0xee, 0xa1, 0x6c, 0xff, 0x6e, 0x06, 0xee, 0xa1, 0x6c, 0x01, 0xd0, 0x11,
    0x80, 0xc4, 0xd0, 0x11, 0x4f, 0x01, 0x12, 0x98, 0x42, 0x00, 0x64, 0x01,
    0x42, 0x3f, 0x64, 0xff, 0x43, 0x00, 0x65, 0x01, 0x43, 0x1f, 0x12, 0xa4,
    0xa2, 0xcb, 0xd2, 0x31, 0x82, 0x44, 0x83, 0x54, 0xd2, 0x31, 0x3f, 0x01,
    0x12, 0x42, 0x43, 0x1e, 0x12, 0x98, 0x6a, 0x02, 0xfa, 0x18, 0x76, 0x01,
    0x46, 0x70, 0x12, 0xaa, 0xd2, 0x31, 0xc4, 0x01, 0x34, 0x01, 0x64, 0xff,
    0xc5, 0x01, 0x35, 0x01, 0x65, 0xff, 0x12, 0x42, 0x6a, 0x03, 0xfa, 0x18,
    0xa2, 0xcb, 0xd2, 0x31, 0x73, 0xff, 0x12, 0x36, 0xa2, 0xcb, 0xd2, 0x31,
    0x12, 0x28, 0xa2, 0xcd, 0xd0, 0x11, 0xa2, 0xf0, 0xf6, 0x33, 0xf2, 0x65,
    0x63, 0x18, 0x64, 0x1b, 0xf0, 0x29, 0xd3, 0x45, 0x73, 0x05, 0xf1, 0x29,
    0xd3, 0x45, 0x73, 0x05, 0xf2, 0x29, 0xd3, 0x45, 0x12, 0xc8, 0x01, 0x80,
    0x44, 0xff
];

function sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

let running = 0;
let currentProgram = gameTetris;

async function main() {
    setupKeyboard(vm);

    vm.loadProgram(currentProgram);
    dumpVM(vm);

    //// following code works, but frequency is not 60hz. Use requestAnimationFrame better.
    // let timer = 0;
    // for(;;)
    // {
    //     if (running) {
    //         // Emulate one cycle
    //         vm.emulateCycle();
    //         dumpVM();
    //
    //         if (timer % 20 == 0) { // let decrementTimers slow than emulateCycle
    //             vm.decrementTimers();
    //             timer = 0
    //         }
    //
    //         // If the draw flag is set, update the screen
    //         if (vm.drawFlag) {
    //             drawGraphics(vm.display);
    //             vm.drawFlag = 0
    //         }
    //
    //     }
    //
    //     await sleep(5);
    // }

    function runLoop() {
        if (running) {
            for (let i = 0; i < 10; i++) { // let emulateCycle fast than decrementTimers
                // Emulate one cycle
                vm.emulateCycle();
                dumpVM(vm);
            }

            vm.decrementTimers();
        }

        // If the draw flag is set, update the screen
        if(vm.drawFlag) {
            drawGraphics(vm.display);
            vm.drawFlag = 0;
        }

        window.requestAnimationFrame(runLoop);  // 60 times per second
    }
    window.requestAnimationFrame(runLoop);  // 60 times per second
}

function setupKeyboard(vm) {
    document.addEventListener('keydown', event => {
        vm.setKey(event.key);
    });

    document.addEventListener('keyup', event => {
        vm.unsetKey();
    })
}

// render input to canvas
function drawGraphics(input) {
    for (let i = 0; i < input.length; i++) {
        let x = (i % DISPLAY_WIDTH) * PIXEL_SIZE;
        let y = Math.floor(i / DISPLAY_WIDTH) * PIXEL_SIZE;

        if (input[i] == 0) {
            myCanvas.fillStyle = DISPLAY_COLOR_BG;
        } else {
            myCanvas.fillStyle = DISPLAY_COLOR_FG;
        }
        myCanvas.fillRect(x, y, PIXEL_SIZE, PIXEL_SIZE);
    }
}

document.getElementById("roms").addEventListener("change", e => {
    let oldProgram = currentProgram
    if (e.target.value == "TETRIS") {
        currentProgram = gameTetris
    } else if (e.target.value == "WIPEOFF") {
        currentProgram = gameWipeoff
    }

    if (currentProgram != oldProgram) {
        vm.loadProgram(currentProgram);
    }
});

runButton = document.getElementById("run-button");
runButton.addEventListener("click", () => {
    if (running) {
        running = false;
        runButton.innerHTML = "Start";
    } else {
        running = true;
        runButton.innerHTML = "Stop";
    }
});

restartButton = document.getElementById("restart-button");
restartButton.addEventListener("click", () => {
    running = true;
    runButton.innerHTML = "Stop";
    vm.loadProgram(currentProgram)
});

stepButton = document.getElementById("step-button");
stepButton.addEventListener("click", () => {
    vm.emulateCycle();
    dumpVM(vm);
    vm.decrementTimers();

    // If the draw flag is set, update the screen
    if(vm.drawFlag) {
        drawGraphics(vm.display);
        vm.drawFlag = 0;
    }
});

function hex(value, length = 4) {
    const padded = "0000" + value.toString(16).toUpperCase();
    return padded.substr(padded.length - length);
}

function inRange(value, lower, upper) { return value >= lower && value <= upper; }

// dissassemble program at addr.
// From https://github.com/ColinEberhardt/wasm-rust-chip8/blob/master/web/chip8.js
function dissassemble(program, addr) {
    const opcode = (program[addr] << 8) | program[addr + 1];

    const x = (opcode & 0x0f00) >> 8;
    const y = (opcode & 0x00f0) >> 4;
    const nnn = opcode & 0x0fff;
    const kk = opcode & 0x00ff;
    const n = opcode & 0x000f;

    if (opcode === 0x00e0) return "CLS";
    if (opcode === 0x00ee) return "RET";
    if (inRange(opcode, 0x1000, 0x1fff)) return `JP 0x${hex(nnn, 3)}`;
    if (inRange(opcode, 0x2000, 0x2fff)) return `CALL 0x${hex(nnn, 3)}`;
    if (inRange(opcode, 0x3000, 0x3fff)) return `SE V${n} ${kk}`;
    if (inRange(opcode, 0x4000, 0x4fff)) return `SNE V${n} ${kk}`;
    if (inRange(opcode, 0x5000, 0x5fff)) return `SE V${x} V${y}`;
    if (inRange(opcode, 0x6000, 0x6fff)) return `LD V${x} ${kk}`;
    if (inRange(opcode, 0x7000, 0x7fff)) return `ADD V${x} ${kk}`;
    if (inRange(opcode, 0x8000, 0x8fff)) {
        if (n === 0x0) return `LD V${x} V${y}`;
        if (n === 0x1) return `OR V${x} V${y}`;
        if (n === 0x2) return `AND V${x} V${y}`;
        if (n === 0x3) return `XOR V${x} V${y}`;
        if (n === 0x4) return `ADD V${x} V${y}`;
        if (n === 0x5) return `SUB V${x} V${y}`;
        if (n === 0x6) return `SHR V${x}`;
        if (n === 0x7) return `SUBN V${x} V${y}`;
        if (n === 0xe) return `SHL V${x}`;
    }
    if (inRange(opcode, 0x9000, 0x9fff)) return `SNE V${x} V${y}`;
    if (inRange(opcode, 0xa000, 0xafff)) return `LDI ${nnn}`;
    if (inRange(opcode, 0xb000, 0xbfff)) return `JP V0 + ${nnn}`;
    if (inRange(opcode, 0xc000, 0xcfff)) return `RND ${kk}`;
    if (inRange(opcode, 0xd000, 0xdfff)) return `DRW V${x} V${y} ${n}`;
    if (inRange(opcode, 0xe000, 0xefff)) {
        if (kk === 0x9e) return `SKP V${x}`;
        if (kk === 0xa1) return `SKNP V${x}`;
    }
    if (inRange(opcode, 0xf000, 0xffff)) {
        if (kk === 0x07) return `LD V${x} DT`;
        if (kk === 0x0a) return `LD V${x} K`;
        if (kk === 0x15) return `LD DT, V${x}`;
        if (kk === 0x1e) return `ADD I, V${x}`;
        if (kk === 0x29) return `LD F, V${x}`;
        if (kk === 0x33) return `LD B, V${x}`;
        if (kk === 0x55) return `LD [I], ${x}`;
        if (kk === 0x65) return `LD ${x}, [I]`;
    }
    return "-";
}

function dumpVM(vm) {
    dumpMemory(vm);
    dumpRegisters(vm);
}

function dumpMemory(vm) {
    deleteChild("memory");
    let pc = vm.pc;
    while (pc < vm.pc + 32) { // only dump 16 opcode
        const clazz = `addr_${pc}`;
        const haddress = "0x" + hex(pc);
        appendChild("memory", `<div class='${clazz}'>${haddress} - ${dissassemble(
            vm.memory, pc)}</div>`);
        pc += 2;
    }
}

function dumpRegisters(vm) {
    deleteChild("register-v");
    for (let i = 0; i < vm.V.length; i++) {
        appendChild("register-v", `<div>V${i}: ${vm.V[i]}</div>`);
    }
    deleteChild("register-others");
    appendChild("register-others", `<div>PC: ${vm.pc}</div>`);
    appendChild("register-others", `<div>I: ${vm.I}</div>`);
}

function deleteChild(id) { // jQuery: empty()
    let e = document.getElementById(id);
    let child = e.lastElementChild;
    while (child) {
        e.removeChild(child);
        child = e.lastElementChild;
    }
}

function appendChild(parentId, html) { // jQuery: append()
    document.getElementById(parentId).insertAdjacentHTML( 'beforeend', html);
}

main();
